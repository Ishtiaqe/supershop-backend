#!/usr/bin/env ts-node
import fs from 'fs';
import path from 'path';
import { PrismaClient } from '@prisma/client';

// Usage: ts-node scripts/query-to-inserts.ts --query "SELECT id, name FROM users WHERE tenantId='...'" --table users --out /tmp/out.sql

function printUsage() {
  console.error('Usage: query-to-inserts.ts --query "SELECT ..." --table <table-name> [--out <file>] [--append]');
}

function parseArgs(): Record<string, string | boolean | undefined> {
  const args = process.argv.slice(2);
  const out: Record<string, string | boolean | undefined> = {};
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a === '--query') {
      out.query = args[++i];
    } else if (a === '--table') {
      out.table = args[++i];
    } else if (a === '--out') {
      out.out = args[++i];
    } else if (a === '--append') {
      out.append = true;
    } else if (a === '-h' || a === '--help') {
      out.help = true;
    } else {
      console.error('Unknown arg', a);
      printUsage();
      process.exit(1);
    }
  }
  return out;
}

function escapeSqlValue(v: any) {
  if (v === null || typeof v === 'undefined') return 'NULL';
  if (typeof v === 'boolean') return v ? 'TRUE' : 'FALSE';
  if (typeof v === 'number') return v.toString();
  if (v instanceof Date) return `'${v.toISOString().replace(/'/g, "''")}'`;
  // strings
  return `'${String(v).replace(/'/g, "''")}'`;
}

async function main() {
  const args = parseArgs();
  if (args.help) {
    printUsage();
    process.exit(0);
  }
  const query = args.query as string | undefined;
  const table = args.table as string | undefined;
  const out = (args.out as string) || path.resolve(__dirname, '..', 'backups', `query-export-${new Date().toISOString().replace(/[:.]/g, '-')}.sql`);
  const append = !!args.append;

  if (!query) {
    console.error('--query is required');
    printUsage();
    process.exit(1);
  }
  if (!table) {
    console.error('--table is required to generate INSERT statements');
    printUsage();
    process.exit(1);
  }

  const prisma = new PrismaClient();
  try {
    const rows = await prisma.$queryRawUnsafe(query);
    if (!Array.isArray(rows)) {
      console.error('Query did not return a result set');
      process.exit(2);
    }
    if (rows.length === 0) {
      console.log('No rows returned. Writing empty SQL file');
    }
    const cols = rows.length > 0 ? Object.keys(rows[0]) : [];
    const lines: string[] = [];
    lines.push(`-- Generated by query-to-inserts.ts on ${new Date().toISOString()}`);
    lines.push('BEGIN;');
    for (const r of rows) {
      const values = cols.map(c => escapeSqlValue((r as any)[c]));
      lines.push(`INSERT INTO ${table} (${cols.join(', ')}) VALUES (${values.join(', ')});`);
    }
    lines.push('COMMIT;');

    fs.mkdirSync(path.dirname(out), { recursive: true });
    if (append && fs.existsSync(out)) {
      fs.appendFileSync(out, lines.join('\n') + '\n');
    } else {
      fs.writeFileSync(out, lines.join('\n') + '\n');
    }
    console.log('Wrote SQL inserts to', out);
    await prisma.$disconnect();
  } catch (err) {
    console.error('Error running query or writing file:', err);
    await prisma.$disconnect();
    process.exit(1);
  }
}

main();
